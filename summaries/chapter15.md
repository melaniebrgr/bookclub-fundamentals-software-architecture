# Chapter 17

There are a couple reasons Willian is wary of microservices. There is no agreement about what it is. There is a battle between Martin Fowler, Same Newson and other folks who are the inventors of microservies. The book aligns with Fowler’s viewpoint and it is the closest and best description. The concept of microservices is a reaction to the SOA pattern (the opinionated version of serviced-based in the book). Microservices is the opposite of the prescriptive SOA approach. With microservices you can do whatever you want and just combine them. You can communicate over different protocols. When we see diagrams microservices in the wild though, it’s always a mess of services. The only thing that is common is that each has access to a single database. There is a reasonf or this: DDD tells us that we should model software based on real life. In that case, when defining boundaries, you're saying that a unique team will control the boundaries of the service. That is the main benefit: it give teams freedom to work independently. Which is also a clue of when we should use them. They are good for bigger teams only. For small teams there is no point. Microservices is also a bad idea if you do not know the business requirements or it's a greenfield project. People tend to think that because they are small things you can have a very performant system, but in general you’re going to add a lot of overhead in terms of communication, as services need to talk to each other.

Another challenge of microservices is traceability. The "sidecar", or sharing things, is generally very against the idea of microservices. Changing one service should not break another. The sidecars, the code that “should be shared” between microservices for treceability should not affect the actual functioning of the microservice at minimum.

When to transition to a microservice architecture? You reach a point where the monolith is blocking development, that is the great time to consider the jump to microservices. Or if you have a long deployment. There is a ton over material on how to address database sharding when taking monoliths to microservices for instance. Build the monolith, feel the pain of it, understand your business domain, then go to microservices.

If you need to talk to multiple services you must have something like a saga or mediator/circuit breaker. The issue then is that the two services are coupled with a mediator or saga. You only do sagas if you need to cancel something given a failure of something else. A saga owns the whole process. In some cases you may not need both service calls to be successful. If the front-end is graphQL, then you can just request the data from the service again. 
